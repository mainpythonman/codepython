## 一、闭包  
使用闭包，可以让程序变得**更简洁易读**  
### 1.1 闭包所需要满足的**条件**：  
1. 外部函数中定义了内部函数  
2. 外部函数有返回值  
3. 返回的值是：内部函数名  
4. 内部函数引用了外部函数的变量值  
### 1.2 闭包的语法格式  
```python
def 外部函数():
    def 内部函数():
        函数体
    return 内部函数名
```  
闭包小案例：
```python 
def fun01():
    a = 1
    def fun02():
        print(a)
    return fun02
# 调用外部函数，返回值是内嵌函数
result = fun01()
# 调用内嵌函数
result()
```
内部函数fun02引用了外部函数变量a，外部函数有返回值，并且返回了内部函数名，所以这就是闭包的实践
### 1.3 闭包的应用代码  
```python
# 闭包应用
# 压岁钱
def give_gife_money(money):
    print('得到了%d压岁钱'%money)
    def child_buy(target,price):
        nonlocal money
        if money>=price:
            money -=price
            print('孩子花了%.1f钱，购买了%s'%(price,target))
        else:
            print('钱不够啦')
    return child_buy
action = give_gife_money(10000)
action('唐僧肉',0.5)
```
由于要修改外部函数变量money所以用nonlocal，此案例就实现了闭包的
> 得到了10000压岁钱  
> 孩子花了0.5钱，购买了唐僧肉  

```python
#计数器
def count():
    container = [0]
    def add_one():
        container[0] = container[0] + 1
        print('当前是第{}次访问'.format(container[0]))
    return add_one
x= count()
x()
x()
x()
```
> 当前是第1次访问  
> 当前是第2次访问  
> 当前是第3次访问
## 二、装饰器  
简言之，**python装饰器**就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。  
**装饰器是给现有的模块增添新的小功能，可以对原函数进行功能扩展，而且还不需要修改原函数的内容，也不需要修改原函数的调用。**  
## 2.1语法   
### 2.1.1 装饰器的定义  
给已有函数增加额外功能的函数，它本质上就是一个闭包函数，用 **@+外层函数名**构成装饰器表示方式。  
装饰器的**功能特点**：
1. 不修改已有函数的源代码
2. 不修改已有函数的调用方式
3. 给已有函数增加额外的功能
4. 被装饰的目标函数执行之前，会先执行装饰部分的代码逻辑，然后执行目标函数逻辑  
  
### 2.1.2 闭包和装饰器的区分  
如果闭包函数的参数有且只有一个，并且是函数类型，那么这个闭包函数称之为装饰器。  
写代码要遵循开放封闭原则，它规定已经实现的功能代码不允许被修改，但可以被扩展。   
**一个简单的案例** 
```python
def decorate(func):
    a=100
    def wrapper():
        print('----------1')
        func()
        print('----------2',a)
    return wrapper
@decorate
def house():
    print('我是毛坯房。。。。')
house()
```
> ----------1  
> 我是毛坯房。。。。  
> ----------2 100
1. house被装饰函数  
2. 将被装饰函数作为参数传给装饰器decorate
3. 执行decorate     
  
**一个复杂点的案例**  
```python
import time
def count_time(func):
    def wrapper():
        t1 = time.time()
        func()
        print("执行时间为：", time.time() - t1)
    return wrapper
@count_time
def baiyu():
    print("我是攻城狮白玉")
    time.sleep(2)
if __name__ == '__main__':
    # baiyu = count_time(baiyu)  # 因为装饰器 count_time(baiyu) 返回的时函数对象 wrapper，这条语句相当于  baiyu = wrapper
    # baiyu()  # 执行baiyu()就相当于执行wrapper()
    baiyu()  # 用语法糖之后，就可以直接调用该函数了
```
> 我是攻城狮白玉  
> 执行时间为： 2.0122079849243164
## 2.2 被装饰函数带参数  
```python
def verify_permissions(func):
    def wrapper(*args,**kwargs):
        print('权限验证')
        func(*args,**kwargs)
    return wrapper
@verify_permissions
def enter_background(a,b):
    print('进入后台')
@verify_permissions
def delete_order(c):
    print('删除订单')
# enter_background = verify_permissions(enter_background)
# delete_order = verify_permissions(delete_order)
enter_background(1,2)
delete_order(3)
```
> 权限验证  
> 进入后台  
> 权限验证  
> 删除订单
## 2.3 带参数的装饰器  
带有参数的装饰器就是使用装饰器装饰函数的时候可以传入指定参数，语法格式: @装饰器(参数,…)。使用带有参数的装饰器，其实是在装饰器外面又包裹了一个函数，使用该函数接收参数，返回是装饰器，因为 @ 符号需要配合装饰器实例使用。  
带参数的装饰器是三层的，最外层的函数负责接收装饰器参数，里面的内容还是原装饰器的内容。  
```python 
#带参数的装饰器
def outer(a):#第一层：负责接受装饰器参数
    def decorate(func):#第二层：接收函数
        def wrapper(*args,**kwargs):#第三层：接收函数的参数
            func(*args,**kwargs)
            print('-----铺地砖{}块'.format(a))
        return wrapper#返回第三层
    return decorate#返回第二层
@outer(10)
def house(time):
    print('我{}日期拿到房子的钥匙，是毛坯房。。。'.format(time))
house('2019-06-12')
```
> 我2019-06-12日期拿到房子的钥匙，是毛坯房。。。  
> -----铺地砖10块
```python 
def return_decorator(flag):
    # 装饰器只能接收一个参数并且是函数类型
    def decorator(func):
        def inner(a, b):
            if flag == '+':
                print('正在努力执行加法计算')
            elif flag == '-':
                print('正在努力执行减法计算')
            func(a, b)
        return inner
    # 当调用函数的时候可以返回一个装饰器decorato
    return decorator
@return_decorator('+')  # decorator = return_decorator('+'), @decorator => add_num = decorator(add_num)
def add_num(a, b):
    result = a + b
    print(result)
@return_decorator('-')
def sub_num(a, b):
    result = a - b
    print(result)
add_num(1, 2)
sub_num(1, 2)
```
> 正在努力执行加法计算  
> 3  
> 正在努力执行减法计算  
> -1

```python 
import time
def count_time_args(msg=None):
    def count_time(func):
        def wrapper(*args, **kwargs):
            t1 = time.time()
            func(*args, **kwargs)
            print(f"[{msg}]执行时间为：", time.time() - t1)

        return wrapper

    return count_time
@count_time_args(msg="baiyu")
def fun_one():
    time.sleep(1)
@count_time_args(msg="zhh")
def fun_two():
    time.sleep(1)
@count_time_args(msg="mylove")
def fun_three():
    time.sleep(1)
if __name__ == '__main__':
    fun_one()
    fun_two()
    fun_three()
```
> [baiyu]执行时间为： 1.0128884315490723  
> [zhh]执行时间为： 1.0082902908325195  
> [mylove]执行时间为： 1.0128865242004395
## 2.4 装饰器的顺序（多层装饰器加强一下）    
```python 
def BaiyuDecorator_1(func):
    def wrapper(*args, **kwargs):
        func(*args, **kwargs)
        print('我是装饰器1')
    return wrapper
def BaiyuDecorator_2(func):
    def wrapper(*args, **kwargs):
        func(*args, **kwargs)
        print('我是装饰器2')
    return wrapper
def BaiyuDecorator_3(func):
    def wrapper(*args, **kwargs):
        func(*args, **kwargs)
        print('我是装饰器3')
    return wrapper
@BaiyuDecorator_1
@BaiyuDecorator_2
@BaiyuDecorator_3
def baiyu():
    print("我是攻城狮白玉")
if __name__ == '__main__':
    baiyu()
# 先运行较近的装饰器，也就是3位置的装饰器，然后是2，最后是1
``` 
> 我是攻城狮白玉  
> 我是装饰器3  
> 我是装饰器2  
> 我是装饰器1
```python
def wrapper1(func1):
    print('set func1')
    def improved_func1():
        print('call func1')
        func1()
    return improved_func1

def wrapper2(func2):
    print('set func2')
    def improved_func2():
        print('call func2')
        func2()
    return improved_func2

@wrapper1
@wrapper2
def original_func():
    pass

if __name__=='__main__':
    original_func()
    print('------')
    original_func()
```
> set func2  
> set func1  
> call func1  
> call func2  
> \-----  
> call func1  
> call func2   
```python 
def decorator1(func):
    print('before_decorated_1')
    def wrapper1():
        print('execute_decorator_1')
        func()
        print('1111111111')

    return wrapper1

def decorator2(func):
    print('before_decorated_2')

    def wrapper2():
        print('execute_decorator_2')
        func()
        print('2222222222')

    return wrapper2

@decorator1
@decorator2
def test():
    print('test result')

```
> before_decorated_2  
> before_decorated_1  
> execute_decorator_1  
> execute_decorator_2  
> test result  
> 2222222222  
> 1111111111  
  
**更复杂的多层装饰器**
```python
# an example of python decorator
def deco1(func):
    print(1)
    def wrapper1():
        print(2)
        func()
        print(3)
    print(4)
    return wrapper1

def deco2(func):
    print(5)
    def wrapper2():
        print(6)
        func()
        print(7)
    print(8)
    return wrapper2

@deco1
@deco2
def foo():
    print('foo')


if __name__ == '__main__':
    foo()
#5
#8
#1
#4
#2
#6
#foo
#7
#3
```
复杂装饰器分析：  
1. 修饰器本质上就是一个函数，只不过它的传入参数同样是一个函数。因此，依次加了deco1和deco2两个装饰器的原函数foo实际上相当于deco1(deco2(foo))。  
2. 明白了第1步后，下面进入这个复合函数。首先执行的是内层函数deco2(foo)。因此第一个打印值是5。接下来要注意，在deco2这个函数内定义了一个wrapper2函数，但是并没有类似于wrapper2()的语句，因此该函数内的语句并没有立即执行，而是作为了返回值。因此wrapper2内的3条语句作为输入参数传递到了deco1内。wrapper2函数内还有一行print(8)，因此第二个打印值为8。  
3. 下一步是执行deco1()函数内容。与2类似，先打印出1和4，返回值为wrapper1。由于更外层没有装饰器，因此接下来就将执行wrapper1内的内容。第五个打印值为2。接着执行func()函数，注意此处func()表示的是wrapper2中的内容，因此跳到wrapper2中执行。第六个打印值为6。类似的，wrapper2中的func()为foo()，因此接着会输出foo。最后，回到wrapper2和wrapper1的最后一行，依次输出7和3。到这里，整个装饰器的运行过程结束。

## 2.5 类装饰器  
### 2.5.1 类装饰器的实现要点
上面咱们一起学习了怎么写装饰器函数，在python中，其实也可以同类来实现装饰器的功能，称之为类装饰器。类装饰器的实现是调用了类里面的__call__函数。类装饰器的写法比我们装饰器函数的写法更加简单。  
当我们将类作为一个装饰器，工作流程：  
> 通过__init__（）方法初始化类  
> 通过__call__（）方法调用真正的装饰方法 
  
### 2.5.2 不带参数的类装饰器 
```python 
import time 
class Timer:
    def __init__(self,func) -> None:
        self.func = func
  
    def __call__(self, *args, **kwargs):
        start = time.time()
        ret = self.func(*args, **kwargs)
        print(f'Time:{time.time()-start}')
        return ret
        
@Timer
def add(a,b):
    time.sleep(1)
    return a+b

print(add(2,3))
```
> Time:1.0087158679962158  
> 5
  
### 2.5.3 带参数的类装饰器
```python 
class BaiyuDecorator:
    def __init__(self, arg1, arg2):  # init()方法里面的参数都是装饰器的参数
        print('执行类Decorator的__init__()方法')
        self.arg1 = arg1
        self.arg2 = arg2
    def __call__(self, func):  # 因为装饰器带了参数，所以接收传入函数变量的位置是这里
        print('执行类Decorator的__call__()方法')
        def baiyu_warp(*args):  # 这里装饰器的函数名字可以随便命名，只要跟return的函数名相同即可
            print('执行wrap()')
            print('装饰器参数：', self.arg1, self.arg2)
            print('执行' + func.__name__ + '()')
            func(*args)
            print(func.__name__ + '()执行完毕')

        return baiyu_warp
@BaiyuDecorator('Hello', 'Baiyu')
def example(a1, a2, a3):
    print('传入example()的参数：', a1, a2, a3)
if __name__ == '__main__':
    print('准备调用example()')
    example('Baiyu', 'Happy', 'Coder')
    print('测试代码执行完毕')
```
> 执行类Decorator的__init__()方法  
> 执行类Decorator的__call__()方法  
> 准备调用example()  
> 执行wrap()  
> 装饰器参数： Hello Baiyu  
> 执行example()  
> 传入example()的参数： Baiyu Happy Coder  
> example()执行完毕  
> 测试代码执行完毕














































